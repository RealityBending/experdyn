% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute_rqa.R
\name{compute_rqa}
\alias{compute_rqa}
\title{Compute Recurrence Quantification Analysis per Participant}
\usage{
compute_rqa(
  data,
  r = 1,
  min_diag = 2L,
  min_vert = 2L,
  participant_col = "ID",
  series_col = "Series_ID",
  time_col = "time",
  verbose = TRUE
)
}
\arguments{
\item{data}{An \code{experdyn_statespace} object returned by \code{\link[=make_statespace]{make_statespace()}},
or a data frame containing lagged columns named \verb{*_lag0}, \verb{*_lag1}, etc.}

\item{r}{\verb{[numeric(1): 1.0]}\cr
Euclidean distance threshold for the recurrence matrix. Data are z-scored
within each subseries before distances are computed, so \code{r} is on a
standardised scale.}

\item{min_diag}{\verb{[integer(1): 2]}\cr
Minimum diagonal line length included in DET, L, and ENTR calculations.}

\item{min_vert}{\verb{[integer(1): 2]}\cr
Minimum vertical line length included in LAM and TT calculations.}

\item{participant_col}{\verb{[character(1): "ID"]}\cr
Participant identifier column.}

\item{series_col}{\verb{[character(1): "Series_ID"]}\cr
Subseries identifier column.}

\item{time_col}{\verb{[character(1): "time"]}\cr
Optional time column used for ordering within subseries.}

\item{verbose}{\verb{[logical(1): TRUE]}\cr
If \code{TRUE}, prints a short completion summary.}
}
\value{
An object of class \code{experdyn_rqa} — a named list with:\tabular{ll}{
   Element \tab Description \cr
   \code{participant_rqa} \tab One row per participant with cross-series mean RQA measures. \cr
   \code{series_rqa} \tab One row per participant-subseries with per-series RQA measures. \cr
   \code{recurrence_data} \tab Sparse data frame of recurrence point coordinates for plotting. \cr
   \code{r} \tab Matching tolerance used. \cr
   \code{min_diag} \tab Minimum diagonal line length used. \cr
   \code{min_vert} \tab Minimum vertical line length used. \cr
}


\strong{RQA measures} (columns in \code{participant_rqa} and \code{series_rqa}):\tabular{ll}{
   Measure \tab Description \cr
   \code{RR} \tab Recurrence Rate — proportion of recurrent points. \cr
   \code{DET} \tab Determinism — proportion of recurrences forming diagonal lines ≥ \code{min_diag}. \cr
   \code{L} \tab Mean diagonal line length. \cr
   \code{Lmax} \tab Longest diagonal line. \cr
   \code{ENTR} \tab Shannon entropy of diagonal line length distribution. \cr
   \code{LAM} \tab Laminarity — proportion of recurrences forming vertical lines ≥ \code{min_vert}. \cr
   \code{TT} \tab Trapping Time — mean vertical line length. \cr
   \code{Vmax} \tab Longest vertical line. \cr
}
}
\description{
Computes standard Recurrence Quantification Analysis (RQA) measures from a
multivariate state-space embedding, separately for each participant.

RQA characterises the temporal organisation of a dynamical system by
examining how often and in what patterns the system revisits previous states.
The function accepts output from \code{\link[=make_statespace]{make_statespace()}} directly — each row of
the embedded matrix is treated as a point in the reconstructed state space.

When multiple subseries exist per participant (e.g., from overnight breaks
detected by \code{\link[=resample_timeseries]{resample_timeseries()}}), RQA is first computed within each
subseries and then averaged to yield participant-level estimates.
}
\examples{
set.seed(1)
n <- 30
t_obs <- as.POSIXct("2025-01-01 09:00:00") +
  cumsum(sample(60 * c(60, 90), n, replace = TRUE))
df <- data.frame(
  time        = t_obs,
  Component_1 = cumsum(rnorm(n)),
  Component_2 = cumsum(rnorm(n))
)
rs  <- resample_timeseries(df, time_col = "time", verbose = FALSE, plot = FALSE)
ss  <- make_statespace(rs)
rqa <- compute_rqa(ss, r = 1.2, verbose = FALSE)
rqa

}
\seealso{
\itemize{
\item \code{\link[=make_statespace]{make_statespace()}} for building the embedding passed to this function.
\item \code{\link[=plot_rqa]{plot_rqa()}} for visualising the recurrence structure.
\item \code{\link[=compute_mvsampen]{compute_mvsampen()}} for sample entropy, a complementary complexity measure.
}
}
